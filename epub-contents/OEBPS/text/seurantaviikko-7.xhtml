<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="fi" lang="fi">
  <head>
    <title>
      3.7 Seurantaviikko 7
    </title>
    <link rel="stylesheet" type="text/css" href="../styles.css" />
  </head>
  <body>
    <h3>
      3.7 Seurantaviikko 7
    </h3>
    <h4>
      Maanantai 19.10.2015
    </h4>
    <p>
      Tavoitteeni tänään on osallistua kahden päivän mittaiseen ”Program Increment”-jakson suunnitteluun. Olen osallistunut aikaisemmin jo yhteen tällaiseen suunnitteluun. Suunnitteluun osallistuu kaikki yhteen tuoteperheeseen liittyvät tiimit ja henkilöt. Tiimejä on noin tusina. Suunnittelupäivinä ei pidetä päiväpalavereja.
    </p>
    <p>
      Suunnittelu alkaa kahden tunnin tilaisuudella, johon kaikkien tiimien jäsenten on tarkoitus osallistua. Tilaisuus pidetään suuressa neuvottelusalissa, jossa on noin 50 henkilöä. Lisäksi tilaisuuteen osallistuu kymmeniä kehittäjiä Skypen välityksellä Oslosta, Kuala Lumpurista, Britanniasta, ja Yhdysvalloista. Tilaisuudessa käydään läpi yrityksen nykytilanne, tuoteperheen visio, tuoteperheen arkkitehtuurin visio, ja suunnittelun konteksti.
    </p>
    <p>
      Tilaisuuden jälkeen scrummasterit osallistuvat ensimmäiseen scrumien scrum -kokoukseen (englanniksi ”scrum of scrums”), jossa he kertovat toisilleen tiimiensä tilanteen alustavasti, samalla tavalla kuin scrumin päiväpalavereissa.
    </p>
    <p>
      Kun scrummasterit palaavat, tiimit kerääntyvät eri kokoushuoneisiin, ja suunnittelevat jaksoa. Erityisen tärkeää suunnittelussa on tarvittavien ja saatavilla olevan työmäärän määritteleminen. Tarvittava työmäärä määritellään tuotteen kehitysjonon työstöllä, jossa jokaiselle tarvittavalle tuotteen toiminnolle määritellään käyttäjätarinapisteet (englanniksi ”story points”). Yksi piste vastaa yrityksemme scrumkäytännöissä yhden työpäivän työtä. Yhdessä sprintissä on täyspäiväisellä työntekijällä kahdeksan pistettä, koska sprintit ovat kahden viikon pituisia, ja jokaisessa viikossa on yleensä viisi työpäivää, ja yleensä sprintistä kaksi työpäivää kuluu sprintin suunnitteluun ja sprintin päättämiseen. Työmäärän saatavuus lasketaan työntekijöiden ennustettujen työ- ja lomapäivien mukaan, ja odotettavan työpanoksen mukaan. Esimerkiksi jos työntekijä on osa-aikainen, harjoittelija, tai tekee opinnäytetyötä, työntekijälle lasketaan vähemmän pisteitä. Kun tarvittavat ja saatavat työmäärät on laskettu, tiimit suunnittelevat alustavasti sprintit seuraavaan jaksoon asti. Vertaamalla sprinttien tarvittavien ja saatavien pisteiden määrää toisiinsa pystytään arvioimaan onko tiimillä liian vähän tai liian paljon kehittäjiä.
    </p>
    <p>
      Tiimien yksittäisten suunnittelujen jälkeen scrummasterit osallistuvat toiseen scrumien scrum -tilaisuuteen, jossa he kertovat toisilleen tiimiensä tilanteen ja suunnitelmat. Tämä jälkeen tuoteomistajat ja arkkitehdit esittävät tiimien suunnitelmat alustavasti ylemmälle johdolle.
    </p>
    <p>
      Tulin suunnittelutilaisuuteen hiukan myöhässä, koska olin olettanut sen olevan samassa kokoushuoneessa kuin edellinen, ja minulla kesti hiukan löytää oikea paikka. Suunnittelutilaisuus ja tuotteen kehitysjonon työstö onnistuivat ongelmitta, vaikka olin aika väsynyt aikaisen herätyksen takia. Saimme työstettyä noin puolet tuotteen tulevista toiminnoista.
    </p>
    <h4>
      Tiistai 20.10.2015
    </h4>
    <p>
      Tavoitteeni tänään on osallistua ”Program Increment”-jakson suunnittelun toiselle päivälle. Toinen päivä aloitetaan jatkamalla tuotteen kehitysjonon työstöä. Lisäksi tiimit tekevät riippuvuus- ja riskikartoitukset.
    </p>
    <p>
      Riippuvuuskartoituksessa tiimi miettii, minkä muiden tiimien toiminnat, ja muut tapahtumat liittyvät heidän työhönsä. Lisäksi halutaan tietää, onko mahdollisia tilanteita, joissa tiimin jäisi jumiin, koska jokin toinen tiimi ei ole tehnyt joitain heille kriittistä asiaa.
    </p>
    <div class="all-one-paragraph" id="roam-viittaus">
      <p>
        Riskikartoituksessa tiimi miettii mahdollisia työtä haittaavia tai estäviä riskejä, ja jaottelee ne neljään ryhmään ROAM-menetelmän mukaan. <cite>All About Agile</cite> -sivuston kirjoittajan Kelly Watersin <a href="lahteet.xhtml#roam">(2012)</a> mukaan ROAM tulee sanoista: ”Resolved”, ”Owned”, ”Accepted”, ja ”Mitigated”:
      </p>
      <ul>
        <li>
          <strong>”Resolved”</strong>, eli ”Ratkaistu”, tarkoittaa riskiä, joka ei ole enää ongelma, koska se on vältetty tai siihen on muuten vastattu.
        </li>
        <li>
          <strong>”Owned”</strong>, eli ”Omistettu”, tarkoittaa riskiä, joka on annettu jonkun henkilön tai tahon vastuulle.
        </li>
        <li>
          <strong>”Accepted”</strong>, eli ”Hyväksytty”, tarkoittaa riskiä, josta on päätetty, ettei sille tehdä mitään.
        </li>
        <li>
          <strong>”Mitigated”</strong>, eli ”Lievennetty”, tarkoittaa riskiä, jonka todennäköisyyttä ja/tai vaikutusta on pienennetty.
        </li>
      </ul>
    </div>
    <p>
      Riippuvuus- ja riskikartoitusten jälkeen tiimit kerääntyvät taas samaan kokoustilaan, ja esittävät toisilleen suunnitelmansa ja kartoituksensa jaksoon. Muut tiimit ja johto kysyy kysymyksiä ja kommentoi niitä.
    </p>
    <p>
      Kun kaikki tiimit ovat esittäneet, pidetään jakson arviointiäänestys. Äänestyksessä paikallaolioilta kysytään, kuinka hyvin he odottavat jakson onnistuvan asteikolla 1-5, ja he vastaavat viittaamalla. Jokaiselle arvolle annetut äänet lasketaan ja kerätään myöhempää yhteen liittämistä ja analyysia varten.
    </p>
    <p>
      Äänestyksen jälkeen pidetään menneen jakson retrospektiivi. Skype-tapaaminen suljetaan tässä vaiheessa, koska retrospektiivi käydään vain paikallisten tiimien välillä. Retrospektiivissä osallistujat jaetaan neljään ryhmään ja he kirjoittavat paperille asioita, jotka aiheuttivat eniten ongelmia jaksossa. Sitten paperit kerätään eteen, ja ongelmat ja niihin liittyvät parannusehdotukset käydään läpi. Lopuksi jokainen osallistuja saa äänestää kahta ongelmaa, joita he eniten haluaisivat korjattavan.
    </p>
    <p>
      Suunnitteluun osallistuminen onnistui suuremmitta ongelmitta, enkä ollut yhtä ymmällään kuin viime kerralla. En vieläkään oikein osannut antaa mitään kritiikkiä retrospektiivissä, mutta oletan että minulla on ensi kerralla jotain huomautettavaa.
    </p>
    <h4>
      Keskiviikko 21.10.2015
    </h4>
    <p>
      Tavoitteeni tänään on osallistua päiväpalaveriin, kirjoittaa kirjoittamatta jääneitä päiväkirjamerkintöjä, ja alustavasti valmistautua opinnäytetyöseminaariin.
    </p>
    <p>
      Päiväpalaveria ei pidetty, koska scrummaster oli toisessa palaverissa sille tarkoitettuna aikana, ja kun hän tuli takaisin osa tiimistä oli mennyt lounastauolle. Scrummaster sai tietää palaverissaan, että lokalisaatio onkin tärkeämpi tuotteen lähitulevaisuudelle kuin aiemmin odotettiin. Tämän takia hän pyysi yhtä kehitystiimin jäsentä tekemään toteutettavuuden osoituksen lokalisaatiosta. Puhuin scrummasterin ja toisen kehittäjän kanssa lokalisaatiosta, koska minulle oli noin kuukausi aiemmin annettu tehtäväksi tutkia kansainvälistämisestä ja lokalisaatiosta. Heidän ei tarvinnut kysyä minulta paljoa, koska oli dokumentoinut tutkimukseni hyvin.
    </p>
    <h4>
      Torstai 22.10.2015
    </h4>
    <p>
      Yritin kirjoittaa päiväkirjamerkintöjä kotona, mutta en saanut oikein mitään kirjoitettua, koska en pystynyt keskittymään kirjoittamiseen.
    </p>
    <h4>
      Perjantai 23.10.2015
    </h4>
    <p>
      Tavoitteeni tänään on osallistua päiväpalaveriin, ja kirjoittaa päiväkirjamerkintöjä.
    </p>
    <p>
      Osallistuin päiväpalaveriin ja kirjoitin päiväkirjamerkintöjä.
    </p>
    <h4>
      Viikkoanalyysi
    </h4>
    <p>
      Käyttöliittymäalustamme käyttää tällä hetkellä pohjanaan Backbone-viitekehystä, jQuery-kirjastoa, ja Handlebars.js-kaavainprosessoria. Näistä työkaluista on kuitenkin suunniteltu luovuttavan, ja siirryttävän käyttämään Facebookin luomia React-kirjastoa ja JSX-ohjelmointikieltä. Tässä viikkoanalyysissä vertaan nykyisiä pääkirjastoja tuleviin kirjastoihin ja analysoin muutosta.
    </p>
    <div class="all-one-paragraph">
      <p>
        Luin tästä muutoksesta analyysin, jonka oli kirjoittanut erään tuotetiimin front-end-johtaja. Analyysissä hän listasi muutaman syyn olla siirtymättä Reactiin:
      </p>
      <ul>
        <li>Se on iso muutos arkkitehtuuriin.</li>
        <li>Kehittäjät pitää kouluttaa käyttämään uusia työkaluja.</li>
        <li>Muutossa on todennäköisesti myös tuntemattomia riskejä.</li>
      </ul>
      <p>
        Hän kuitenkin löysi paljon syitä siirtymisen puolesta, lyhennetysti:
      </p>
      <ul>
        <li>
          Nykyisessä tavassa on vaikea löytää, mikä näkymä luo minkäkin HTML-koodinpätkän; tämä on helpompaa Reactilla, koska esimerkiksi Google Chromella on liitännäinen, jolla pystyy näkemään React-komponentin nimen HTML-koodista.
        </li>
        <li>
          React-komponenttien uudelleenkäyttö on paljon helpompaa kuin Handlebars-kaavojen käyttö. Erityisesti Reactilla on helpompaa käyttää sisäkkäisiä näkymiä.
        </li>
        <li>
          Nykyisessä tavassa HTML-luokkia käytetään JavaScript-, ja CSS-koodissa. Näin ollen on vaikea tietää, kumpaan (vai kumpaankin) kyseistä luokkaa käytetään. Reactissa ei tarvitse viitata HTML-luokkiin.
        </li>
        <li>
          Backbone-näkymissä pitää kirjoittaa ”siivous”-koodia, jossa oliot, joita ei enää käytetä, piti kytkeä pois käytössä olevista komponenteista, jotta ne eivät jää turhaan muistiin. React hoitaa ”siivouksen” automaattisesti.
        </li>
        <li>
          Nykyisessä tavassa, jos esimerkiksi siirtää tekstikenttää lennossa, sen sisältö pitää manuaalisesti kopioida JavaScript-muuttujaan, ja sitten siirtää takaisin tekstikenttäelementtiin, kun siirto on valmis, koska tekstikentän tila katoaa siirrossa. React huolehtii automaattisesti tilan siirtämisestä.
        </li>
        <li>
          Koodi on Reactilla ”matemaattisempaa”.
        </li>
      </ul>
    </div>
    <p>
      Mielestäni hän kuvaa hyvin osuvasti nykyisen arkkitehtuurin ongelmia. Minullakin on ollut usein vaikeuksia löytää, mihin komponenttiin jokin HTML-koodi kuuluu, ja olen jsokus joutunut käyttämään tunninkin etsimiseen. Minun ei ole ollut ongelmia sisäkkäisten komponenttien käytössä, mutta on mahdollista, että se on helpompaa Reactilla. Minulla on ollut usein vaikeuksia varmistaa käytetäänkö HTML-luokka JavaScript-koodissa, vai CSS-koodissa, vai kummassakin. Tämä on ollut erityisen hankalaa, kun olen miettinyt jonkin luokan poistamista tai uudelleennimeämistä. Voin sanoa kokemuksesta, että ”siivous”-koodimme on hyvin sekavaa, ja siihen muutosten tekeminen hyvin vaikeaa ja aikaa vievää.
    </p>
    <p>
      Olen törmännyt joihinkin ongelmiin tilallisten elementtien siirtämisessä, mutta en yhtä suuriin kuin hän. Hänen esimerkki oli käyttämämme taulukkokomponentti, jonka elementtien aakkostamisessa joutui siirtämään satoja tilallisia elementtejä. Tällaisessa tilanteessa tilan säilymisen varmistaminen on hyvin hankalaa, ja virheiden tekeminen on hyvin todennäköistä.
    </p>
    <p>
      Kysyin kehittäjältä mitä hän tarkoitti Reactin ”matemaattisuudella”. Lyhyen keskustelun jälkeen tajusin että hän tarkoitti ”deklaratiivisempaa”, muttei vain muistanut tätä sanaa. Deklaratiivisessa ohjelmoinnissa tietokoneelle kerrotaan <em>mitä</em> sen tulee saada aikaiseksi, muttei <em>miten</em>. SQL-tietokantakyselyt ovat klassinen esimerkki deklaratiivisesta ohjelmoinnista. Kyselyissä tietokoneelle esimerkiksi kerrotaan <em>mitä</em> tietoja halutaan sen hakevan tietokannasta, mutta ei <em>miten</em> sen tulee hakea ne. Tässä on kaksi hyvää puolta: (1) Tietokannan käyttäjän ei tarvitse miettiä minkälaisia esimerkiksi kierteitä haku tarvitse. (2) Deklaratiivinen kysely antaa tietokannan tekijälle vapaat kädet päättää kyselyn toteutuksesta, kunhan se vain palauttaa oikean tuloksen; tällöin tietokannan tekijä voi optimoida kyselyiden toimintaa ilman että käyttäjän tarvitsee tehdä mitään näiden optimointien hyödyntämiseen.
    </p>
    <p>
      Deklaratiivisen ohjelmoinnin vastakohta on imperatiivinen ohjelmointi, jossa tietokoneelle kerrotaan <em>miten</em> sen tulee päästä tulokseen. Imperatiivisessa ohjelmoinnissa tietokoneelle annetaan tarkat askelittaiset komentosarjat. Imperatiivinen ohjelmointi on usein yleisempää mitä alempitasoinen ohjelmointikieli on. Lisäksi ohjelmointi on imperatiivisessa yleensä tilallisempaa. Funktionaalinen ohjelmointi usein katsotaan liittyvän vahvasti deklaratiiviseen ohjelmointiin. Viime vuosina funktionaalisen ohjelmoinnin (ja näin ollen deklaratiivisen ohjelmoinnin) suosio on kasvanut. Tämä johtuu aiemmasta funktionaalisen ja deklaratiivisen koodin verrattaisesta hitaudesta ja suuresta resurssien käytöstä. JavaScriptissä on kumpiakin deklaratiivisia ja imperatiivisia piirteitä, ja se on vahvasti funktionaalinen kieli.
    </p>
  </body>
</html>
